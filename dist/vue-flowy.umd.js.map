{"version":3,"sources":["webpack://vue-flowy/webpack/universalModuleDefinition","webpack://vue-flowy/webpack/bootstrap","webpack://vue-flowy/./src/VueFlowy.vue?7e67","webpack://vue-flowy/./src/graph/layout/Size.js","webpack://vue-flowy/./src/graph/layout/Position.js","webpack://vue-flowy/./src/graph/layout/Style.js","webpack://vue-flowy/./src/graph/Node.js","webpack://vue-flowy/./src/graph/layout/Layering.js","webpack://vue-flowy/./src/graph/layout/Normalizer.js","webpack://vue-flowy/./src/graph/Layout.js","webpack://vue-flowy/./src/graph/Edge.js","webpack://vue-flowy/./src/Graph.js","webpack://vue-flowy/./src/graph/Svg.js","webpack://vue-flowy/./src/graph/Shape.js","webpack://vue-flowy/./src/graph/Label.js","webpack://vue-flowy/./src/Renderer.js","webpack://vue-flowy/./src/FlowElement.js","webpack://vue-flowy/./src/FlowChart.js","webpack://vue-flowy/src/VueFlowy.vue","webpack://vue-flowy/./src/VueFlowy.vue?5f4e","webpack://vue-flowy/./node_modules/vue-loader/lib/runtime/componentNormalizer.js","webpack://vue-flowy/./src/VueFlowy.vue","webpack://vue-flowy/./src/main.ts","webpack://vue-flowy/./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js","webpack://vue-flowy/./src/VueFlowy.vue?f6aa","webpack://vue-flowy/./node_modules/path-browserify/index.js","webpack://vue-flowy/./src/VueFlowy.vue?d96d","webpack://vue-flowy/./src/VueFlowy.vue?3fec","webpack://vue-flowy/./node_modules/ms/index.js","webpack://vue-flowy/./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://vue-flowy/./node_modules/css-loader/lib/css-base.js","webpack://vue-flowy/./node_modules/debug/src/browser.js","webpack://vue-flowy/./node_modules/node-libs-browser/mock/process.js","webpack://vue-flowy/./node_modules/vue-style-loader/lib/listToStyles.js","webpack://vue-flowy/./node_modules/vue-style-loader/lib/addStylesClient.js","webpack://vue-flowy/./node_modules/debug/src/debug.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;AClFA,0BAA0B,aAAa,0BAA0B,wBAAwB,iBAAiB,gCAAgC,eAAe;AACzJ;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;ACNA;AACA;AACA;AACA;AACA,gBAAgB,+CAA+C;AAC/D,wBAAwB;AACxB;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,eAAe,2CAA2C;AAC1D,uBAAuB;AACvB;AACA;AACA,iC;;ACjBA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,gBAAgB;AAChB;AACA;AACA,oC;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA,yDAAyD,uBAAuB;AAChF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sC;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+CAA+C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0CAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAiC,iBAAiB;AAClD,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF,iBAAiB;AACjB;AACA,4CAA4C,WAAW,QAAQ,kCAAkC,UAAU,mCAAmC,EAAE,EAAE;AAClJ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,gC;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;AC5CA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kEAA4D,yBAAyB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAAwF,6DAA6D;AACrJ;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kEAA4D,0BAA0B;AACtF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oC;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAA0C;AACnE;AACA;AACA;AACA,uC;;ACXA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;ACrCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9B0K,0GAAoB,C;;;;;ACA9L;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AC5FkC;AAClC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8D;;ACnBqC;AAEF;AAEnC,MAAM,MAAM,GAAG;IACb,kBAAQ;IACR,8BAAS;IACT,OAAO,CAAE,GAAmB;QAC1B,GAAG,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC;IACxC,CAAC;CACF;AAED,yCAAe,MAAM;AAES;;;;;ACd9B;AACA;+EACA;AACA;;;;;;;;ACHA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qCAAqC,E;;;;;;;ACRlF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;AC/NA;AACA;;;AAGA;AACA,yCAA0C,cAAc,cAAc,uBAAuB,YAAY,UAAU,mBAAmB,2BAA2B,YAAY,mBAAmB;;AAEhM;;;;;;;;;;;;ACP2Z,8dAAoB,C;;;;;;;ACA/a;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvJA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;;AAElE;AACA;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;AClMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACA;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA","file":"vue-flowy.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vue-flowy\"] = factory();\n\telse\n\t\troot[\"vue-flowy\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"+xUi\");\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"flowyChart\",attrs:{\"id\":_vm._uid}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default class Size {\n    constructor() {\n        this.height = 0;\n        this.width = 0;\n    }\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n}\n//# sourceMappingURL=Size.js.map","export default class Position {\n    constructor() {\n        this.x = 0;\n        this.y = 0;\n    }\n}\n//# sourceMappingURL=Position.js.map","export default class Style {\n    constructor() {\n        this.shape = 'rect';\n    }\n    setPadding({ left = 10, top = 10, right = 10, bottom = 10 }) {\n        this.padding = { left, top, right, bottom };\n    }\n    setBorderRadius(radius = { rx: 0, ry: 0 }) {\n        this.radius = radius;\n    }\n    setShape(shapeType) {\n        this.shape = shapeType;\n    }\n    setBorder({ left = 0, top = 0, right = 0, bottom = 0 }) {\n        this.border = { left, top, right, bottom };\n    }\n}\n//# sourceMappingURL=Style.js.map","import Size from './layout/Size';\nimport Position from './layout/Position';\nimport Style from './layout/Style';\nexport default class GraphNode {\n    constructor(id, options = {}) {\n        this.label = '';\n        this.parent = null;\n        this.children = {};\n        this.position = new Position();\n        this.size = new Size();\n        this.style = new Style();\n        this.rank = 0;\n        this.order = 0;\n        this.inEdges = {};\n        this.outEdges = {};\n        this.successors = {};\n        this.predecessors = {};\n        this.borders = {};\n        this.id = id;\n        this.setOptions(options);\n    }\n    setOptions(options) {\n        if (!options.label) {\n            options.label = this.id;\n        }\n        Object.assign(this, options);\n    }\n}\n//# sourceMappingURL=Node.js.map","import Graph from '../../Graph';\nimport debug from 'debug';\nconst log = debug('layering');\nexport default class Layering {\n    constructor(graph) {\n        this.graph = graph;\n        log('creating matrix once');\n        this.matrix = this.buildLayerMatrix();\n    }\n    buildLayerMatrix() {\n        const layering = [];\n        log('NODES FOR MATRIX is', Object.assign({}, this.graph.nodes));\n        this.graph.nodes.forEach(node => {\n            if (!layering[node.rank]) {\n                layering[node.rank] = [];\n            }\n            layering[node.rank][node.order] = node;\n        });\n        return layering;\n    }\n    calculatePositions() {\n        this._calculateYPositions();\n        this._calculateXPositions();\n    }\n    _calculateYPositions() {\n        let prevY = 0;\n        this.matrix.forEach(layer => {\n            const maxHeight = Math.max(...layer.map(node => {\n                return node.size.height;\n            }));\n            layer.forEach(node => {\n                log('assigning y', node.id, prevY, maxHeight / 2, prevY + maxHeight / 2);\n                node.position.y = prevY + maxHeight / 2;\n            });\n            prevY += maxHeight + this.graph.rankSep;\n        });\n    }\n    _calculateXPositions() {\n        if (!this.graph.layout) {\n            throw new Error('Layout is not set yet!');\n        }\n        log('is', this.buildLayerMatrix());\n        const xPositions = {};\n        let adjustedLayering;\n        const verticals = ['u', 'd'];\n        const horizontals = ['l', 'r'];\n        verticals.forEach(vert => {\n            adjustedLayering =\n                vert === 'u' ? this.matrix : Object.values(this.matrix).reverse();\n            horizontals.forEach(horiz => {\n                if (horiz === 'r') {\n                    adjustedLayering = adjustedLayering.map(inner => Object.values(inner).reverse());\n                }\n                log('adjusted layering is', adjustedLayering);\n                const align = this._verticalAlignment(adjustedLayering, vert, horiz);\n                let xs = this._horizontalCompaction(adjustedLayering, align, horiz === 'r');\n                log(vert + horiz, xs);\n                if (horiz === 'r') {\n                    for (const key in xs) {\n                        xs[key] = -xs[key];\n                    }\n                }\n                xPositions[vert + horiz] = xs;\n            });\n        });\n        log('xPositions finish', xPositions);\n        const smallestWidthAlignment = this._findSmallestWidthAlignment(xPositions);\n        log('smallestWidth is', smallestWidthAlignment);\n        this._alignCoordinates(xPositions, smallestWidthAlignment);\n        return this.graph.layout.balance(xPositions);\n    }\n    _alignCoordinates(xPositions, smallestWidthAlignment) {\n        const alignToVals = Object.values(smallestWidthAlignment);\n        const alignToMin = Math.min(...alignToVals);\n        const alignToMax = Math.max(...alignToVals);\n        const verticals = ['u', 'd'];\n        const horizontals = ['l', 'r'];\n        verticals.forEach(vert => {\n            horizontals.forEach(horiz => {\n                const alignment = vert + horiz;\n                const xs = xPositions[alignment];\n                if (xs === smallestWidthAlignment) {\n                    return;\n                }\n                const xsVals = Object.values(xs);\n                const delta = horiz === 'l'\n                    ? alignToMin - Math.min(...xsVals)\n                    : alignToMax - Math.max(...xsVals);\n                if (delta) {\n                    for (const i in xs) {\n                        xs[i] += delta;\n                    }\n                    xPositions[alignment] = xs;\n                }\n            });\n        });\n    }\n    _findSmallestWidthAlignment(xPositions) {\n        let minWidth = Infinity;\n        let minXs = {};\n        Object.values(xPositions).forEach(xs => {\n            let minVal = Infinity;\n            let maxVal = -Infinity;\n            Object.keys(xs).forEach(nodeId => {\n                const no = xs[nodeId];\n                const check = no - this.graph.getNode(nodeId).size.width / 2;\n                if (check < minVal) {\n                    minVal = check;\n                }\n                if (check > maxVal) {\n                    maxVal = check;\n                }\n            });\n            const minCheck = maxVal - minVal;\n            if (minCheck < minWidth) {\n                minWidth = minCheck;\n                minXs = xs;\n            }\n        });\n        return minXs;\n    }\n    _horizontalCompaction(layering, align, reverseSep) {\n        log('horizontalCompaction', layering, align, reverseSep);\n        const xs = {};\n        const blockGraph = Graph.buildBlockGraph(layering, align.root, reverseSep);\n        const visited = {};\n        function pass1(node) {\n            if (visited[node.id]) {\n                return;\n            }\n            visited[node.id] = true;\n            xs[node.id] = blockGraph.inEdges(node).reduce((max, edge) => {\n                pass1(edge.from);\n                return Math.max(max, xs[edge.from.id] + (edge.maxSep || 0));\n            }, 0);\n        }\n        blockGraph.nodes.forEach(pass1);\n        Object.keys(align.align).forEach(nodeId => {\n            xs[nodeId] = xs[align.root[nodeId].id];\n        });\n        return xs;\n    }\n    _verticalAlignment(layering, vert, horiz) {\n        const root = {};\n        const align = {};\n        const pos = {};\n        layering.forEach(layer => {\n            layer.forEach((node, order) => {\n                root[node.id] = node;\n                align[node.id] = node;\n                pos[node.id] = order;\n            });\n        });\n        log('objects after first step is', root, align, pos);\n        layering.forEach(layer => {\n            let prevIdx = -1;\n            layer.forEach(node => {\n                let ws = vert === 'u'\n                    ? this.graph.getPredecessors(node)\n                    : this.graph.getSuccessors(node);\n                if (!ws.length) {\n                    return;\n                }\n                if (!this.graph.layout) {\n                    throw new Error('Layout for graph is not set!');\n                }\n                ws = this.graph.layout.sortByFunction(ws, w => pos[w]);\n                const mp = (ws.length - 1) / 2;\n                for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; i++) {\n                    const w = ws[i];\n                    if (align[node.id].id === node.id && prevIdx < pos[w]) {\n                        align[w] = node;\n                        align[node.id] = root[node.id] = root[w];\n                        prevIdx = pos[w];\n                    }\n                }\n            });\n        });\n        return { root, align };\n    }\n}\n//# sourceMappingURL=Layering.js.map","import debug from 'debug';\nconst log = debug('normalizer');\nexport default class Normalizer {\n    constructor(graph) {\n        this.graph = graph;\n    }\n    normalize() {\n        this.graph.dummyChain = [];\n        log('EDGES', this.graph.edges);\n        this.graph.edges.forEach(this._normalizeEdge, this);\n    }\n    _normalizeEdge(edge) {\n        if (edge.to.rank === edge.from.rank + 1) {\n            return;\n        }\n        for (let i = edge.from.rank + 1; i < edge.to.rank; i++) {\n            edge.points = [];\n            let dummy = this.graph.addDummyNode('edge', { rank: edge.from.rank }, '_d');\n            this.graph.setEdge(edge.from.id, dummy.id, {\n                weight: edge.weight\n            });\n            if (i === edge.from.rank + 1) {\n                this.graph.dummyChain.push(dummy);\n            }\n        }\n    }\n}\n//# sourceMappingURL=Normalizer.js.map","import Graph from '../Graph';\nimport debug from 'debug';\nimport Layering from './layout/Layering';\nimport Normalizer from './layout/Normalizer';\nconst ldb = debug('layout');\nexport default class Layout {\n    constructor(graph) {\n        this.graph = graph;\n        this.normalizer = new Normalizer(this.graph);\n        ldb('creating layering once');\n        this.layering = new Layering(this.graph);\n        this.runLayout();\n    }\n    runLayout() {\n        this.makeSpaceForEdgeLabels();\n        this.createNestingGraph();\n        this.rank();\n        this.cleanupNestingGraph();\n        this.normalizeRanks();\n        this.assignRankMinMax();\n        this.normalizer.normalize();\n        this.order();\n        this.adjustCoordinateSystem();\n        this.layering.calculatePositions();\n        this.undoCoordinateSystem();\n        this.translateGraph();\n    }\n    makeSpaceForEdgeLabels() {\n        this.graph.rankSep /= 2;\n        ldb(this.graph);\n        this.graph.edges.forEach(edge => {\n            ldb('making space for edge', edge);\n            edge.minLen *= 2;\n            if (edge.labelPos.toLowerCase() === 'c') {\n                return;\n            }\n            if (this.graph.rankDir === 'tb' || this.graph.rankDir === 'bt') {\n                edge.size.width += edge.labelOffset;\n            }\n            else {\n                edge.size.height += edge.labelOffset;\n            }\n        });\n    }\n    createNestingGraph() {\n        ldb('creating nesting graph');\n        this.graph.rootNode = this.graph.setNode('_root', { dummy: 'root' });\n        const depths = this.treeDepths();\n        ldb('depths', depths);\n        const height = Math.max(...Object.values(depths)) - 1;\n        this.graph.nodeRankFactor = 2 * height + 1;\n        this.graph.edges.forEach(edge => {\n            edge.minLen *= this.graph.nodeRankFactor;\n        });\n        const weight = this.graph.edges.reduce((prevVal, edge) => prevVal + edge.weight, 0);\n        this.graph.getChildren().forEach(child => {\n            ldb('calling dfs with', this.graph.rootNode, this.graph.nodeRankFactor, weight, height, depths, child);\n            this.dfs(this.graph.rootNode, weight, height, depths, child);\n        });\n        ldb('edges after nesting graph', this.graph.edges.length);\n    }\n    cleanupNestingGraph() {\n        if (this.graph.rootNode) {\n            this.graph.removeNode(this.graph.rootNode.id);\n        }\n        delete this.graph['rootNode'];\n        this.graph.edges.forEach(edge => {\n            if (edge.nestingEdge) {\n                this.graph.removeEdge(edge.id);\n            }\n        });\n        ldb('edges after cleanup nesting graph', this.graph.edges.length, this.graph.edges);\n    }\n    normalizeRanks() {\n        const minRank = this.minRank();\n        this.graph.nodes.forEach(node => (node.rank -= minRank));\n    }\n    assignRankMinMax() {\n        let maxRank = 0;\n        this.graph.nodes.forEach(node => {\n            if (!node.borders.top || !node.borders.bottom) {\n                return;\n            }\n            node.minRank = node.borders.top.rank;\n            node.maxRank = node.borders.bottom.rank;\n            maxRank = Math.max(maxRank, node.maxRank);\n        });\n        this.graph.maxRank = maxRank;\n    }\n    treeDepths() {\n        const depths = {};\n        const layout = this;\n        function dfs(node, depth = 1) {\n            const children = Object.values(node.children);\n            ldb('children of', node, 'are', children, '. depth:', depth);\n            children.forEach(child => {\n                ldb('child', child);\n                dfs(child, depth + 1);\n            });\n            depths[node.id] = depth;\n        }\n        this.graph.getChildren().forEach(child => {\n            dfs(child);\n        });\n        return depths;\n    }\n    dfs(rootNode, weight, height, depths, node) {\n        const children = Object.values(node.children);\n        ldb('DFS:', children.length, 'children of', node, children);\n        if (!children.length) {\n            if (node.id !== rootNode.id) {\n                this.graph.setEdge(rootNode.id, node.id, { weight: 0, minLen: this.graph.nodeRankFactor });\n            }\n            ldb('returning!');\n            return;\n        }\n        ldb('not returning');\n        const top = this.addBorderNode('_bt');\n        const bottom = this.addBorderNode('_bb');\n        node.borders = { top, bottom };\n        this.graph.setParent(top.id, node.id);\n        this.graph.setParent(bottom.id, node.id);\n        children.forEach(child => {\n            this.dfs(rootNode, weight, height, depths, child);\n            const childTop = child.borders.top ? child.borders.top : child;\n            const childBottom = child.borders.bottom ? child.borders.bottom : child;\n            const thisWeight = Object.keys(child.borders).length ? weight : 2 * weight;\n            const minLen = childTop !== childBottom ? 1 : height - depths[node.id] + 1;\n            this.graph.setEdge(top.id, childTop.id, {\n                weight: thisWeight,\n                minLen: minLen,\n                nestingEdge: true\n            });\n            this.graph.setEdge(childBottom.id, bottom.id, {\n                weight: thisWeight,\n                minLen: minLen,\n                nestingEdge: true\n            });\n        });\n        if (!this.graph.getParent(node.id)) {\n            this.graph.setEdge(rootNode.id, top.id, {\n                weight: 0,\n                minLen: height + depths[node.id]\n            });\n        }\n    }\n    addBorderNode(prefix, rank, order) {\n        const node = {\n            width: 0,\n            height: 0\n        };\n        if (rank && order) {\n            node.rank = rank;\n            node.order = order;\n        }\n        return this.graph.addDummyNode('border', node, prefix);\n    }\n    rank() {\n        switch (this.graph.ranker) {\n            case 'network-simplex':\n                this.networkSimplexRanker();\n                break;\n            case 'tight-tree':\n                break;\n            case 'longest-path':\n                break;\n            default:\n                this.networkSimplexRanker();\n                break;\n        }\n    }\n    position() {\n        this.positionY();\n    }\n    positionX() {\n        ldb('creating matrix in positionX');\n        const matrix = this.layering.buildLayerMatrix();\n    }\n    positionY() {\n        let prevY = 0;\n        this.layering.matrix.forEach(layer => {\n            const maxHeight = Math.max(...layer.map(node => node.size.height));\n            layer.forEach(node => {\n                ldb('assigning y', node.id, prevY, maxHeight / 2, prevY + maxHeight / 2);\n                node.position.y = prevY + maxHeight / 2;\n            });\n            prevY += maxHeight + this.graph.rankSep;\n        });\n    }\n    balance(xPositions) {\n        for (const nodeId in xPositions.ul) {\n            const xs = Object.values(Object.values(xPositions)).map(xs => xs[nodeId]).sort();\n            xPositions.ul[nodeId] = xs[1] + xs[2] / 2;\n        }\n        return xPositions;\n    }\n    networkSimplexRanker() {\n        this.longestPath();\n        this.feasibleTree();\n    }\n    longestPath() {\n        const layout = this;\n        const visited = {};\n        function _longestPath(node) {\n            if (visited[node.id]) {\n                return node.rank;\n            }\n            visited[node.id] = true;\n            const min = Math.min(...layout.graph.outEdges(node).map(outEdge => {\n                return _longestPath(outEdge.to) - outEdge.minLen;\n            }));\n            const rank = min === Infinity ? 0 : min;\n            return (node.rank = rank);\n        }\n        this.graph.sources.forEach(_longestPath);\n    }\n    feasibleTree() {\n        this.treeGraph = new Graph({ directed: false });\n        const start = this.graph.nodeIds[0];\n        const size = this.graph.nodeIds.length;\n        this.treeGraph.setNode(start);\n        ldb('start is', start, 'size is', size);\n        let edge;\n        let delta;\n        let doneTimes = 0;\n        while (this.tightTree() < size) {\n            edge = this.findMinSlackEdge();\n            if (edge === null) {\n                throw new Error('min slack edge is null!');\n            }\n            delta = this.treeGraph.hasNode(edge.from.id)\n                ? this.slack(edge)\n                : -this.slack(edge);\n            this.shiftRanks(delta);\n            doneTimes++;\n            if (doneTimes > 200) {\n                throw new Error('too many loops, breaking now!');\n            }\n        }\n    }\n    tightTree() {\n        const layout = this;\n        const treeGraph = this.treeGraph;\n        function dfs(node) {\n            ldb('nodeEdges', layout.graph.nodeEdges(node));\n            layout.graph.nodeEdges(node).forEach(edge => {\n                ldb('nodeEdge for', node.id, edge);\n                const to = node.id === edge.from.id ? edge.to : edge.from;\n                ldb('not hasNode', !treeGraph.hasNode(to.id), 'not slack', !layout.slack(edge));\n                if (!treeGraph.hasNode(to.id) && !layout.slack(edge)) {\n                    ldb('adding node to tighttree', to);\n                    treeGraph.setNode(to.id);\n                    treeGraph.setEdge(node.id, to.id);\n                    dfs(to);\n                }\n            });\n        }\n        treeGraph.nodes.forEach(dfs);\n        ldb('tightTree size is', treeGraph.nodeIds.length);\n        return treeGraph.nodeIds.length;\n    }\n    findMinSlackEdge() {\n        let minSlackEdge = null;\n        let minSlack = Infinity;\n        ldb('finding min slack edge');\n        this.graph.edges.forEach(edge => {\n            if (this.treeGraph.hasNode(edge.from.id) !==\n                this.treeGraph.hasNode(edge.to.id)) {\n                const slack = this.slack(edge);\n                if (slack < minSlack) {\n                    minSlackEdge = edge;\n                    minSlack = slack;\n                }\n            }\n        });\n        return minSlackEdge;\n    }\n    slack(edge) {\n        ldb('calculating slack of', edge, edge.to.rank, edge.from.rank, edge.minLen);\n        return edge.to.rank - edge.from.rank - edge.minLen;\n    }\n    order() {\n        const maxRank = this.maxRank();\n        const layering = this.initOrder();\n        ldb('LAYERING', layering);\n        this.assignOrder(layering);\n    }\n    buildLayerGraph(rank, relationship) {\n        const graph = new Graph({ compound: true });\n        graph.rootNode = graph.setNode('_root', { dummy: 'root' });\n        this.graph.nodes.forEach(node => {\n            const parent = node.parent;\n            if (!node.minRank || !node.maxRank) {\n                throw new Error('minRank or maxRank not defined!');\n            }\n            if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n                const newNode = graph.setNode(node.id);\n                graph.setParent(node.id, parent ? parent.id : graph.rootNode ? graph.rootNode.id : '');\n                let edges = [];\n                if (relationship === 'in') {\n                    edges = this.graph.inEdges(node);\n                }\n                else if (relationship === 'out') {\n                    edges = this.graph.outEdges(node);\n                }\n                edges.forEach(edge => {\n                    const to = edge.from.id === node.id ? edge.to : edge.from;\n                    const newEdge = graph.getEdge(to.id, node.id);\n                    const weight = edge ? newEdge.weight : 0;\n                    graph.setEdge(to.id, node.id, { weight: edge.weight + weight });\n                });\n                if (node.minRank && node.borders.left && node.borders.right) {\n                    graph.setNode(node.id, { borders: { left: { [rank]: node.borders.left[rank] }, right: { [rank]: node.borders.right[rank] } } });\n                }\n            }\n        });\n    }\n    buildLayerGraphs(ranks, relationship) {\n        return ranks.map(rank => this.buildLayerGraph(rank, relationship));\n    }\n    initOrder() {\n        const layout = this;\n        const visited = {};\n        const simpleNodes = this.graph.nodes.filter(node => !this.graph.getChildren(node.id).length);\n        const maxRank = this.maxRank(simpleNodes);\n        const layers = [];\n        function dfs(node) {\n            if (visited[node.id]) {\n                return;\n            }\n            visited[node.id] = true;\n            if (!layers[node.rank]) {\n                layers[node.rank] = [];\n            }\n            layers[node.rank].push(node);\n            layout.graph.getSuccessors(node).forEach(nodeId => {\n                dfs(layout.graph.getNode(nodeId));\n            });\n        }\n        function compare(a, b) {\n            if (a.rank < b.rank) {\n                return -1;\n            }\n            if (a.rank > b.rank) {\n                return 1;\n            }\n            return 0;\n        }\n        const orderedNodeIds = simpleNodes.sort(compare);\n        orderedNodeIds.forEach(dfs, this);\n        return layers;\n    }\n    assignOrder(layering) {\n        layering.forEach(layer => {\n            layer.forEach((node, index) => {\n                node.order = index;\n            });\n        });\n    }\n    adjustCoordinateSystem() {\n        if (this.graph.rankDir === 'lr' || this.graph.rankDir === 'rl') {\n            this.swapWidthHeight();\n        }\n    }\n    undoCoordinateSystem() {\n        if (this.graph.rankDir === 'bt' || this.graph.rankDir === 'rl') {\n        }\n        if (this.graph.rankDir === 'lr' || this.graph.rankDir === 'rl') {\n            this.swapXY();\n            this.swapWidthHeight();\n        }\n    }\n    _swapWidthHeightOne(o) {\n        const w = o.size.width;\n        o.size.width = o.size.height;\n        o.size.height = w;\n    }\n    swapWidthHeight() {\n        this.graph.nodes.forEach(this._swapWidthHeightOne);\n        this.graph.edges.forEach(this._swapWidthHeightOne);\n    }\n    _swapXYOne(o) {\n        const x = o.position.x;\n        o.position.x = o.position.y;\n        ldb('y before', o.position.y, 'after', x);\n        o.position.y = x;\n        ldb('now', { x: o.position.x, y: o.position.y });\n    }\n    swapXY() {\n        this.graph.nodes.forEach(this._swapXYOne);\n        this.graph.edges.forEach(edge => {\n            edge.points.forEach(this._swapXYOne);\n            if (edge.position.x) {\n                this._swapXYOne(edge);\n            }\n        });\n    }\n    maxRank(nodes = this.graph.nodes) {\n        return nodes.reduce((prevV, node) => {\n            return node.rank > prevV ? node.rank : prevV;\n        }, -Infinity);\n    }\n    minRank(nodes = this.graph.nodes) {\n        return nodes.reduce((prevV, node) => {\n            return node.rank < prevV ? node.rank : prevV;\n        }, Infinity);\n    }\n    shiftRanks(delta) {\n        if (!this.treeGraph) {\n            throw new Error('treeGraph is not defined!');\n        }\n        this.treeGraph.nodes.forEach(node => {\n            node.rank += delta;\n        });\n    }\n    translateGraph() {\n        let minX = Infinity;\n        let maxX = 0;\n        let minY = Infinity;\n        let maxY = 0;\n        const marginX = this.graph.marginX || 0;\n        const marginY = this.graph.marginY || 0;\n        function getExtremes(o) {\n            const x = o.position.x || 0;\n            const y = o.position.y || 0;\n            const w = o.size.width || 0;\n            const h = o.size.height || 0;\n            minX = Math.min(minX, x - w / 2);\n            maxX = Math.max(maxX, x + w / 2);\n            minY = Math.min(minY, y - h / 2);\n            maxY = Math.max(maxY, y + h / 2);\n        }\n        this.graph.nodes.forEach(getExtremes);\n        this.graph.edges.forEach(edge => {\n            if (edge.position.x) {\n                getExtremes(edge);\n            }\n        });\n        minX -= marginX;\n        minY -= marginY;\n        this.graph.nodes.forEach(node => {\n            node.position.x -= minX;\n            node.position.y -= minY;\n        });\n        this.graph.edges.forEach(edge => {\n            edge.points.forEach(point => {\n                point.position.x -= minX;\n                point.position.y -= minY;\n            });\n            if (edge.position.x) {\n                edge.position.x -= minX;\n            }\n            if (edge.position.y) {\n                edge.position.y -= minY;\n            }\n        });\n        this.graph.size.width = maxX - minX + marginX;\n        this.graph.size.height = maxY - minY + marginY;\n    }\n    sortBy(arr, key) {\n        function compare(a, b) {\n            if (a[key] < b[key]) {\n                return -1;\n            }\n            if (a[key] > b[key]) {\n                return 1;\n            }\n            return 0;\n        }\n        return arr.sort(compare);\n    }\n    sortByFunction(arr, fn) {\n        function compare(a, b) {\n            if (fn(a) < fn(b)) {\n                return -1;\n            }\n            if (fn(a) > fn(b)) {\n                return 1;\n            }\n            return 0;\n        }\n        return arr.sort(compare);\n    }\n}\n//# sourceMappingURL=Layout.js.map","import Position from \"./layout/Position\";\nimport Size from \"./layout/Size\";\nconst DEFAULT_EDGE_NAME = '\\x00';\nconst EDGE_KEY_DELIM = '\\x01';\nexport default class Edge {\n    constructor(id, from, to, options) {\n        this.order = 0;\n        this.points = [];\n        this.data = {};\n        this.position = new Position();\n        this.size = new Size();\n        this.minLen = 1;\n        this.weight = 1;\n        this.labelOffset = 10;\n        this.labelPos = 'r';\n        this.nestingEdge = false;\n        this.id = id;\n        this.from = from;\n        this.to = to;\n        this.setOptions(options);\n    }\n    static generateId(fromId, toId, directed = false, name) {\n        if (!directed && fromId > toId) {\n            const tmp = fromId;\n            fromId = toId;\n            toId = tmp;\n        }\n        return fromId + EDGE_KEY_DELIM + toId + EDGE_KEY_DELIM + (name ? name : DEFAULT_EDGE_NAME);\n    }\n    setOptions(options = {}) {\n        Object.assign(this, options);\n    }\n}\n//# sourceMappingURL=Edge.js.map","import GraphNode from './graph/Node';\nimport Layout from './graph/Layout';\nimport Edge from './graph/Edge';\nimport debug from 'debug';\nimport Style from '@/graph/layout/Style';\nimport Size from '@/graph/layout/Size';\nconst gdb = debug('graph');\nconst GRAPH_NODE = '\\x00';\nexport default class Graph {\n    constructor(options = {}) {\n        this._nodes = {};\n        this._edges = {};\n        this.size = new Size();\n        this.style = new Style();\n        this.nodeRankFactor = 0;\n        this.compound = false;\n        this.multiGraph = false;\n        this.directed = true;\n        this.rankDir = 'tb';\n        this.minX = 0;\n        this.minY = 0;\n        this.maxX = 0;\n        this.maxY = 0;\n        this.marginX = 20;\n        this.marginY = 20;\n        this.randomId = 1;\n        this.dummyChain = [];\n        this.rankSep = 50;\n        this.edgeSep = 20;\n        this.nodeSep = 50;\n        this.ranker = 'network-simplex';\n        Object.assign(this, options);\n        this.rankDir = this.rankDir.toLowerCase();\n    }\n    setNode(id, options = {}) {\n        if (this._nodes[id]) {\n            if (options) {\n                this._nodes[id].setOptions(options);\n            }\n            return this._nodes[id];\n        }\n        gdb('creating node', id, options);\n        this._nodes[id] = new GraphNode(id, options);\n        return this._nodes[id];\n    }\n    removeNode(id) {\n        gdb('removing node id', id);\n        const node = this._nodes[id];\n        if (!node) {\n            return;\n        }\n        Object.keys(node.inEdges).forEach(this.removeEdge, this);\n        Object.keys(node.outEdges[id]).forEach(this.removeEdge, this);\n        delete this._nodes[id];\n    }\n    setEdge(fromId, toId, options = {}) {\n        gdb('setting edge', fromId, toId, options);\n        const edgeId = Edge.generateId(fromId, toId, this.directed, options.name);\n        if (this._edges[edgeId]) {\n            if (options) {\n                this._edges[edgeId].setOptions(options);\n            }\n            return this;\n        }\n        const fromNode = this.setNode(fromId);\n        const toNode = this.setNode(toId);\n        const edge = new Edge(edgeId, fromNode, toNode, options);\n        this._edges[edgeId] = edge;\n        fromNode.outEdges[edgeId] = edge;\n        toNode.inEdges[edgeId] = edge;\n        return this;\n    }\n    removeEdge(id) {\n        gdb('removing edge', id);\n        if (!this._edges[id]) {\n            gdb('edge', id, 'does not exist. returning...');\n            return;\n        }\n        const edge = this._edges[id];\n        delete this._edges[id];\n    }\n    addDummyNode(type, attrs, name) {\n        name = name + this.randomId++;\n        attrs.dummy = type;\n        return this.setNode(name, attrs);\n    }\n    getNode(id) {\n        return this._nodes[id];\n    }\n    getEdge(fromId, toId) {\n        return this._edges[Edge.generateId(fromId, toId, this.directed)];\n    }\n    getChildren(id) {\n        if (!id) {\n            return this.nodes;\n        }\n        if (this.compound) {\n            return Object.values(this._nodes[id].children);\n        }\n        else {\n            return [];\n        }\n    }\n    getParent(id) {\n        if (!this.compound) {\n            return null;\n        }\n        const parent = this._nodes[id].parent;\n        if (parent !== null && parent.id !== GRAPH_NODE) {\n            return parent;\n        }\n        return null;\n    }\n    getPredecessors(node) {\n        return node.predecessors ? Object.keys(node.predecessors) : [];\n    }\n    getSuccessors(node) {\n        return node.successors ? Object.keys(node.successors) : [];\n    }\n    setParent(id, parentId) {\n        if (!this.compound) {\n            throw new Error('Cannot set parent in a non-compound graph');\n        }\n        if (parentId === '') {\n            throw new Error('Cannot set parent id to an empty id! (parentId is an empty string)');\n        }\n        let ancestor = parentId;\n        while (ancestor) {\n            const parent = this.getParent(ancestor);\n            if (!parent) {\n                ancestor = null;\n                continue;\n            }\n            if (ancestor === id) {\n                throw new Error('Setting ' +\n                    parentId +\n                    ' as parent of ' +\n                    id +\n                    ' would create a cycle');\n            }\n            ancestor = parent.id;\n        }\n        let parentNode = this.setNode(parentId);\n        let childNode = this.setNode(id);\n        this._nodes[id].parent = parentNode;\n        parentNode.children[id] = childNode;\n    }\n    nodeEdges(from, to) {\n        const inEdges = this.inEdges(from, to);\n        if (inEdges) {\n            return inEdges.concat(this.outEdges(from, to));\n        }\n        return [];\n    }\n    isSubgraph(id) {\n        return this.getChildren(id).length !== 0;\n    }\n    doLayout() {\n        gdb('layouting graph');\n        this.layout = new Layout(this);\n    }\n    hasNode(id) {\n        return this._nodes[id];\n    }\n    get nodes() {\n        return Object.values(this._nodes);\n    }\n    get edges() {\n        return Object.values(this._edges);\n    }\n    get sources() {\n        return this.nodes.filter(node => {\n            return Object.keys(node.inEdges).length === 0;\n        });\n    }\n    inEdges(from, to) {\n        if (!from.inEdges) {\n            return [];\n        }\n        const edges = Object.values(from.inEdges);\n        if (!to) {\n            return edges;\n        }\n        return edges.filter(edge => edge.from.id === to.id);\n    }\n    outEdges(from, to) {\n        if (!from.outEdges) {\n            return [];\n        }\n        const edges = Object.values(from.outEdges);\n        if (!to) {\n            return edges;\n        }\n        return edges.filter(edge => edge.to.id === to.id);\n    }\n    get nodeIds() {\n        return Object.keys(this._nodes);\n    }\n    static buildBlockGraph(layering, root, reverseSep) {\n        const blockGraph = new Graph();\n        layering.forEach(layer => {\n            let to;\n            layer.forEach(node => {\n                blockGraph.setNode(root[node.id].id);\n                if (!to) {\n                    to = node;\n                    return;\n                }\n                const prevMax = blockGraph.getEdge(root[to.id].id, root[node.id].id);\n                gdb('CHECK PREVMAX FROM STABLE');\n                blockGraph.setEdge(root[to.id].id, root[node.id].id, {\n                    maxSep: Math.max(blockGraph.sep(reverseSep, node, to), 0)\n                });\n                to = node;\n            });\n        });\n        return blockGraph;\n    }\n    sep(reverseSep, from, to) {\n        let sum = 0;\n        let delta;\n        sum += from.size.width / 2;\n        gdb('CHECK LABEL POS');\n        if (delta) {\n            sum += reverseSep ? delta : -delta;\n        }\n        delta = 0;\n        sum += (from.dummy ? this.edgeSep : this.nodeSep) / 2;\n        sum += (to.dummy ? this.edgeSep : this.nodeSep) / 2;\n        sum += to.size.width / 2;\n        if (delta) {\n            sum += reverseSep ? delta : -delta;\n        }\n        delta = 0;\n        return sum;\n    }\n}\n//# sourceMappingURL=Graph.js.map","export default class GraphSvg {\n    constructor(el) {\n        if (el instanceof SVGGraphicsElement) {\n            this.node = el;\n        }\n        else {\n            this.node = document.createElementNS('http://www.w3.org/2000/svg', el);\n        }\n    }\n    append(el) {\n        if (!(el instanceof GraphSvg)) {\n            el = new GraphSvg(el);\n        }\n        this.node.appendChild(el.node);\n        return el;\n    }\n    attr(attribute, value) {\n        this.node.setAttribute(attribute, value);\n        return this;\n    }\n    select(selector) {\n        const res = this.node.querySelector(selector);\n        if (res instanceof SVGGraphicsElement) {\n            return new GraphSvg(res);\n        }\n        else if (res) {\n            throw new TypeError('The selected element is not of type \"SVGGraphicsElement\"');\n        }\n        return null;\n    }\n    selectAll(selector) {\n        const res = this.node.querySelectorAll(selector);\n        return Array.from(res).filter(node => node instanceof SVGGraphicsElement).map(node => new GraphSvg(node));\n    }\n    text(s) {\n        const el = document.createTextNode(s);\n        this.node.appendChild(el);\n        return this;\n    }\n    addClass(c) {\n        this.node.classList.add(c);\n        return this;\n    }\n}\n//# sourceMappingURL=Svg.js.map","import GraphSvg from '../graph/Svg';\nexport default class Shape {\n    constructor(shapeType, bbox, options) {\n        this.shape = this[shapeType](bbox, options);\n    }\n    rect(bbox, { rx = '0', ry = '0' }) {\n        return new GraphSvg('rect')\n            .attr('rx', rx)\n            .attr('ry', ry)\n            .attr('x', (-bbox.width / 2).toString())\n            .attr('y', (-bbox.height / 2).toString())\n            .attr('width', bbox.width.toString())\n            .attr('height', bbox.height.toString());\n    }\n}\n//# sourceMappingURL=Shape.js.map","import GraphSvg from './Svg';\nexport default class GraphLabel {\n    constructor(options) {\n        this.group = new GraphSvg('g');\n        this.labelData = options;\n        this.textLabel();\n    }\n    textLabel() {\n        const text = this.group.append('text').text(this.labelData.label);\n    }\n}\n//# sourceMappingURL=Label.js.map","import Shape from './graph/Shape';\nimport GraphLabel from './graph/Label';\nexport default class Renderer {\n    constructor(graph) {\n        this.graph = graph;\n    }\n    render(svg) {\n        console.log('rendering', svg, this.graph);\n        const edgePathsGroup = this.createOrSelectGroup(svg, 'edgePaths');\n        const edgeLabels = this.createEdgeLabels(this.createOrSelectGroup(svg, 'edgeLabels'));\n        this.createNodes(this.createOrSelectGroup(svg, 'nodes'));\n        this.graph.doLayout();\n        let minX = 1000;\n        let minY = 1000;\n        let maxX = -1000;\n        let maxY = -1000;\n        this.graph.nodes.forEach(node => {\n            minX = Math.min(minX, node.position.x - node.size.width / 2);\n            minY = Math.min(minY, node.position.y - node.size.height / 2);\n            maxX = Math.max(maxX, node.position.x + node.size.width / 2);\n            maxY = Math.max(maxY, node.position.y + node.size.height / 2);\n        });\n        this.graph.edges.forEach(edge => {\n            if (edge.position.x && edge.position.y) {\n                minX = Math.min(minX, edge.position.x - edge.size.width / 2);\n                minY = Math.min(minY, edge.position.y - edge.size.height / 2);\n                maxX = Math.max(maxX, edge.position.x + edge.size.width / 2);\n                maxY = Math.max(maxY, edge.position.y + edge.size.height / 2);\n            }\n            const points = edge.points.slice(1, edge.points.length - 1);\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                minX = Math.min(minX, point.x);\n                minY = Math.min(minY, point.y);\n                maxX = Math.max(maxX, point.x);\n                maxY = Math.max(maxY, point.y);\n            }\n        });\n        this.graph.minX = minX;\n        this.graph.minY = minY;\n        this.graph.maxX = maxX;\n        this.graph.maxY = maxY;\n        console.log('GRAPH', this.graph);\n        this.positionNodes();\n    }\n    createNodes(selection) {\n        const simpleNodes = this.graph.nodeIds.filter(id => {\n            return !this.graph.isSubgraph(id);\n        });\n        this.graph.nodes.forEach(graphNode => {\n            const nodeGroup = selection.append('g').addClass('node');\n            const labelGroup = nodeGroup.append('g').addClass('label');\n            const label = labelGroup.append(new GraphLabel({ label: graphNode.label }).group);\n            const labelBBox = label.node.getBBox();\n            if (graphNode.style.padding) {\n                labelBBox.width +=\n                    graphNode.style.padding.left + graphNode.style.padding.right;\n                labelBBox.height +=\n                    graphNode.style.padding.top + graphNode.style.padding.bottom;\n                labelGroup.attr('transform', 'translate(' +\n                    (graphNode.style.padding.left - graphNode.style.padding.right) / 2 +\n                    ',' +\n                    (graphNode.style.padding.top - graphNode.style.padding.bottom) / 2 +\n                    ')');\n            }\n            if (!graphNode.style.shape) {\n                throw new Error('no shape is defined!');\n            }\n            const shape = nodeGroup.append(new Shape(graphNode.style.shape, labelBBox, { width: graphNode.size.width, height: graphNode.size.height }).shape);\n            const shapeBBox = shape.node.getBBox();\n            graphNode.size.setSize(shapeBBox.width, shapeBBox.height);\n            nodeGroup.append(labelGroup);\n            graphNode.svgGroup = nodeGroup;\n        });\n    }\n    createEdgeLabels(selection) {\n        let svgEdgeLabels = selection.selectAll('g.edgeLabel');\n        this.graph.edges.forEach(edge => {\n            const edgeLabelGroup = selection.append('g').addClass('edgeLabel');\n            const labelGroup = edgeLabelGroup.append('g').addClass('label');\n            const label = labelGroup.append(new GraphLabel({ label: edge.label || '' }).group);\n            const labelBBox = label.node.getBBox();\n            edge.size.width = edge.size.width || labelBBox.width;\n            edge.size.height = edge.size.height || labelBBox.height;\n        });\n    }\n    positionNodes() {\n        console.log('position nodes', this.graph.nodes, 'with edges', this.graph.edges);\n        this.graph.nodes.forEach(node => {\n            if (!node.svgGroup) {\n                return;\n            }\n            node.svgGroup.attr('transform', 'translate(' +\n                (node.position.x || 0) +\n                ',' +\n                (node.position.y || 0) +\n                ')');\n        });\n    }\n    createOrSelectGroup(root, name) {\n        return root.select('g.' + name) || root.append('g').addClass(name);\n    }\n}\n//# sourceMappingURL=Renderer.js.map","export default class FlowElement {\n    constructor(id, options) {\n        this.edges = [];\n        this.id = id;\n        this.options = options;\n    }\n    leadsTo(destinationElement, options) {\n        this.edges.push({ otherId: destinationElement.id, options });\n        return destinationElement;\n    }\n}\n//# sourceMappingURL=FlowElement.js.map","import Graph from './Graph';\nimport Renderer from './Renderer';\nimport FlowElement from './FlowElement';\nimport GraphSvg from './graph/Svg';\nexport default class FlowChart {\n    constructor(options = {}) {\n        this.elements = [];\n        localStorage.debug = 'layout,normalizer,layering';\n    }\n    addElement(id, options) {\n        const el = new FlowElement(id, options);\n        this.elements.push(el);\n        return el;\n    }\n    render(element) {\n        const svg = new GraphSvg('svg');\n        svg.node.id = 'f' + element.id;\n        element.appendChild(svg.node);\n        const group = svg.append('g');\n        const graph = new Graph({\n            multiGraph: true,\n            compound: true,\n            rankDir: 'LR',\n            marginX: 20,\n            marginY: 20\n        });\n        for (const i in this.elements) {\n            const el = this.elements[i];\n            graph.setNode(el.id, el.options);\n        }\n        for (const node of graph.nodes) {\n            node.style.radius = { rx: 5, ry: 5 };\n        }\n        for (const i in this.elements) {\n            const el = this.elements[i];\n            for (const k in el.edges) {\n                const edge = el.edges[k];\n                graph.setEdge(el.id, edge.otherId, edge.options);\n            }\n        }\n        const renderer = new Renderer(graph);\n        renderer.render(group);\n    }\n}\n//# sourceMappingURL=FlowChart.js.map","<template>\n  <div \n    :id=\"_uid\" \n    class=\"flowyChart\"/>\n</template>\n\n<script>\nimport FlowChart from './FlowChart'\n\nexport default {\n  name: 'VueFlowy',\n  props: {\n    chart: {\n      type: FlowChart,\n      required: true\n    }\n  },\n  data() {\n    return {\n      chartElement: null\n    }\n  },\n  watch: {\n    'chart.elements': function(newVal, oldVal) {\n      this.chart.render(this.chartElement)\n    }\n  },\n  mounted() {\n    this.chartElement = document.getElementById(this._uid)\n  }\n}\n</script>\n\n<style lang=\"scss\">\n.flowyChart {\n  svg {\n    display: block;\n    margin: 0 auto;\n  }\n\n  .node rect {\n    stroke: #999;\n    fill: #fff;\n    stroke-width: 1.5px;\n  }\n\n  .edgePath path {\n    stroke: #333;\n    stroke-width: 1.5px;\n  }\n}\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=script&lang=js\"","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","import { render, staticRenderFns } from \"./VueFlowy.vue?vue&type=template&id=6244c0f8\"\nimport script from \"./VueFlowy.vue?vue&type=script&lang=js\"\nexport * from \"./VueFlowy.vue?vue&type=script&lang=js\"\nimport style0 from \"./VueFlowy.vue?vue&type=style&index=0&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import VueFlowy from './VueFlowy.vue'\nimport { VueConstructor } from 'vue';\nimport FlowChart from './FlowChart'\n\nconst Plugin = {\n  VueFlowy,\n  FlowChart,\n  install (Vue: VueConstructor) {\n    Vue.component(VueFlowy.name, VueFlowy)\n  }\n}\n\nexport default Plugin\n\nexport { VueFlowy, FlowChart }\n","import './setPublicPath'\nimport mod from '~entry'\nexport default mod\nexport * from '~entry'\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=style&index=0&lang=scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"6b43ab32\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".flowyChart svg{display:block;margin:0 auto}.flowyChart .node rect{stroke:#999;fill:#fff;stroke-width:1.5px}.flowyChart .edgePath path{stroke:#333;stroke-width:1.5px}\", \"\"]);\n\n// exports\n","import mod from \"-!../node_modules/vue-style-loader/index.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=style&index=0&lang=scss\"; export default mod; export * from \"-!../node_modules/vue-style-loader/index.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=style&index=0&lang=scss\"","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  let i\n  if ((i = window.document.currentScript) && (i = i.src.match(/(.+\\/)[^/]+\\.js$/))) {\n    __webpack_public_path__ = i[1] // eslint-disable-line\n  }\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","exports.nextTick = function nextTick(fn) {\n\tsetTimeout(fn, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nexport default function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nimport listToStyles from './listToStyles'\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nexport default function addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n"],"sourceRoot":""}