{"version":3,"sources":["webpack://vue-flowy/webpack/bootstrap","webpack://vue-flowy/./src/VueFlowy.vue?33d2","webpack://vue-flowy/./src/Graph.js","webpack://vue-flowy/./node_modules/dagre-d3-renderer/lib/intersect/intersect-rect.js","webpack://vue-flowy/./node_modules/dagre-d3-renderer/lib/intersect/intersect-ellipse.js","webpack://vue-flowy/./node_modules/dagre-d3-renderer/lib/intersect/intersect-circle.js","webpack://vue-flowy/./node_modules/dagre-d3-renderer/lib/intersect/intersect-line.js","webpack://vue-flowy/./node_modules/dagre-d3-renderer/lib/intersect/intersect-polygon.js","webpack://vue-flowy/./node_modules/dagre-d3-renderer/lib/shapes.js","webpack://vue-flowy/./src/Renderer.js","webpack://vue-flowy/./src/FlowElement.js","webpack://vue-flowy/./src/FlowChart.js","webpack://vue-flowy/src/VueFlowy.vue","webpack://vue-flowy/./src/VueFlowy.vue?c451","webpack://vue-flowy/./node_modules/vue-loader/lib/runtime/componentNormalizer.js","webpack://vue-flowy/./src/VueFlowy.vue","webpack://vue-flowy/./src/main.js","webpack://vue-flowy/./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js","webpack://vue-flowy/./src/VueFlowy.vue?fe04","webpack://vue-flowy/./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://vue-flowy/./src/VueFlowy.vue?2514"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;ACnEA,0BAA0B,aAAa,0BAA0B,wBAAwB,iBAAiB,gCAAgC,eAAe;AACzJ;;;;;;ACDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;ACnGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;;;AC/BA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;;;ACvBA;;AAEA;AACA;AACA;;AAEA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;;;AChEA;;AAEA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA,OAAO,8BAA8B,GAAG,8BAA8B;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;ACtDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,cAAc;AACnB,KAAK,cAAc;AACnB,KAAK,aAAa;AAClB,KAAK;AACL;AACA;AACA,6CAA6C,yBAAyB;;AAEtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AC9EA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,8BAA8B;AACpF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;AClCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,0CAA0C;AAC/D;AACA;AACA;;;ACXA,YAAY;AACZ,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9EA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9BuH,0GAAoB,C;;;;;ACA3I;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AC5FkC;AAClC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8D;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAAgB;;;ACXhB;AACA;+EACA;AACA;;;;;;;;;;;;ACHmW,6aAAoB,C;;;;;;;ACAvX;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA,uC","file":"vue-flowy.common.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"+xUi\");\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"flowyChart\",attrs:{\"id\":_vm._uid}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","const GRAPH_NODE = '\\x00'\nconst DEFAULT_EDGE_NAME = '\\x00'\nconst EDGE_KEY_DELIM = '\\x01'\n\nfunction edgeArgsToId(directed, v, w, name) {\n  if (!directed && v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name || DEFAULT_EDGE_NAME)\n}\n\nexport default class Graph {\n  constructor(options) {\n    this.directed = options.directed || true\n    this.multiGraph = options.multiGraph || false\n    this.compound = options.compound || false\n\n    // v -> label\n    this._nodes = {}\n\n    if (this.compound === true) {\n      this.parent = {}\n      this.children = {}\n      this.children[GRAPH_NODE] = {}\n    }\n\n    // v -> edgeObj\n    this.in = {}\n\n    // u -> v -> Number\n    this.preds = {}\n\n    // v -> edgeObj\n    this.out = {}\n\n    // v -> w -> Number\n    this.sucs = {}\n\n    // e -> edgeObj\n    this.edgeObjs = {}\n\n    // e -> label\n    this.edgeLabels = {}\n  }\n\n  setGraph(label) {\n    this.label = label\n  }\n\n  setNode(v, value) {\n    if (this._nodes[v]) {\n      if (value) {\n        this._nodes[v] = value\n      }\n      return this\n    }\n\n    this._nodes[v] = value || null\n\n    if (this.compound === true) {\n      this.parent[v] = GRAPH_NODE\n      this.children[v] = {}\n      this.children[GRAPH_NODE][v] = true\n    }\n    this.in[v] = {}\n    this.preds[v] = {}\n    this.out[v] = {}\n    this.sucs[v] = {}\n    this.nodeCount++\n    return this\n  }\n\n  setEdge(from, to, options) {\n    this.setNode(from)\n    this.setNode(to)\n\n    const e = edgeArgsToId(this.directed, from, to, name)\n\n    if (this.edgeLabels[e]) {\n      if (options) {\n        this.edgeLabels[e] = options\n      }\n      return this\n    }\n\n    this.out[from]\n    this.in[to]\n    this.edgeCount++\n  }\n\n  getNode(id) {\n    return this._nodes[id]\n  }\n\n  get nodes() {\n    return Object.values(this._nodes)\n  }\n}\n","function intersectRect (node, point) {\n  const x = node.x\n  const y = node.y\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  const dx = point.x - x\n  const dy = point.y - y\n  let w = node.width / 2\n  let h = node.height / 2\n\n  let sx, sy\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h\n    }\n    sx = dy === 0 ? 0 : h * dx / dy\n    sy = h\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w\n    }\n    sx = w\n    sy = dx === 0 ? 0 : w * dy / dx\n  }\n\n  return {x: x + sx, y: y + sy}\n}\n\nexport default intersectRect\n","function intersectEllipse (node, rx, ry, point) {\n  // Formulae from: http://mathworld.wolfram.com/Ellipse-LineIntersection.html\n\n  const cx = node.x\n  const cy = node.y\n\n  const px = cx - point.x\n  const py = cy - point.y\n\n  const det = Math.sqrt(rx * rx * py * py + ry * ry * px * px)\n\n  let dx = Math.abs(rx * ry * px / det)\n  if (point.x < cx) {\n    dx = -dx\n  }\n  let dy = Math.abs(rx * ry * py / det)\n  if (point.y < cy) {\n    dy = -dy\n  }\n\n  return {x: cx + dx, y: cy + dy}\n}\n\nexport default intersectEllipse\n","import intersectEllipse from './intersect-ellipse'\n\nfunction intersectCircle (node, rx, point) {\n  return intersectEllipse(node, rx, rx, point)\n}\n\nexport default intersectCircle\n","/*\n * Returns the point at which two lines, p and q, intersect or returns\n * undefined if they do not intersect.\n */\nfunction intersectLine (p1, p2, q1, q2) {\n  // Algorithm from J. Avro, (ed.) Graphics Gems, No 2, Morgan Kaufmann, 1994,\n  // p7 and p473.\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is F(x,y) = a1 x +\n  // b1 y + c1 = 0.\n  const a1 = p2.y - p1.y\n  const b1 = p1.x - p2.x\n  const c1 = (p2.x * p1.y) - (p1.x * p2.y)\n\n  // Compute r3 and r4.\n  const r3 = ((a1 * q1.x) + (b1 * q1.y) + c1)\n  const r4 = ((a1 * q2.x) + (b1 * q2.y) + c1)\n\n  // Check signs of r3 and r4. If both point 3 and point 4 lie on\n  // same side of line 1, the line segments do not intersect.\n  if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {\n    return /* DONT_INTERSECT */\n  }\n\n  // Compute a2, b2, c2 where line joining points 3 and 4 is G(x,y) = a2 x + b2 y + c2 = 0\n  const a2 = q2.y - q1.y\n  const b2 = q1.x - q2.x\n  const c2 = (q2.x * q1.y) - (q1.x * q2.y)\n\n  // Compute r1 and r2\n  const r1 = (a2 * p1.x) + (b2 * p1.y) + c2\n  const r2 = (a2 * p2.x) + (b2 * p2.y) + c2\n\n  // Check signs of r1 and r2. If both point 1 and point 2 lie\n  // on same side of second line segment, the line segments do\n  // not intersect.\n  if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {\n    return /* DONT_INTERSECT */\n  }\n\n  // Line segments intersect: compute intersection point.\n  const denom = (a1 * b2) - (a2 * b1)\n  if (denom === 0) {\n    return /* COLLINEAR */\n  }\n\n  const offset = Math.abs(denom / 2)\n\n  // The denom/2 is to get rounding instead of truncating. It\n  // is added or subtracted to the numerator, depending upon the\n  // sign of the numerator.\n  let num = (b1 * c2) - (b2 * c1)\n  const x = (num < 0) ? ((num - offset) / denom) : ((num + offset) / denom)\n\n  num = (a2 * c1) - (a1 * c2)\n  const y = (num < 0) ? ((num - offset) / denom) : ((num + offset) / denom)\n\n  return { x, y }\n}\n\nfunction sameSign (r1, r2) {\n  return r1 * r2 > 0\n}\n\nexport default intersectLine\n","import intersectLine from './intersect-line'\n\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\nfunction intersectPolygon (node, polyPoints, point) {\n  const x1 = node.x\n  const y1 = node.y\n\n  const intersections = []\n\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  polyPoints.forEach(function (entry) {\n    minX = Math.min(minX, entry.x)\n    minY = Math.min(minY, entry.y)\n  })\n\n  const left = x1 - node.width / 2 - minX\n  const top = y1 - node.height / 2 - minY\n\n  for (let i = 0; i < polyPoints.length; i += 1) {\n    const p1 = polyPoints[i]\n    const p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0]\n    const intersect = intersectLine(node, point,\n      {x: left + p1.x, y: top + p1.y}, {x: left + p2.x, y: top + p2.y})\n    if (intersect) {\n      intersections.push(intersect)\n    }\n  }\n\n  if (!intersections.length) {\n    console.log('NO INTERSECTION FOUND, RETURN NODE CENTER', node)\n    return node\n  }\n\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function (p, q) {\n      const pdx = p.x - point.x\n      const pdy = p.y - point.y\n      const distp = Math.sqrt(pdx * pdx + pdy * pdy)\n\n      const qdx = q.x - point.x\n      const qdy = q.y - point.y\n      const distq = Math.sqrt(qdx * qdx + qdy * qdy)\n\n      return (distp < distq) ? -1 : (distp === distq ? 0 : 1)\n    })\n  }\n  return intersections[0]\n}\n\nexport default intersectPolygon\n","import intersectRect from './intersect/intersect-rect'\nimport intersectEllipse from './intersect/intersect-ellipse'\nimport intersectCircle from './intersect/intersect-circle'\nimport intersectPolygon from './intersect/intersect-polygon'\n\nfunction rect (parent, bbox, node) {\n  const shapeSvg = parent.insert('rect', ':first-child')\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', -bbox.width / 2)\n    .attr('y', -bbox.height / 2)\n    .attr('width', bbox.width)\n    .attr('height', bbox.height)\n\n  node.intersect = function (point) {\n    return intersectRect(node, point)\n  }\n\n  return shapeSvg\n}\n\nfunction ellipse (parent, bbox, node) {\n  const rx = bbox.width / 2\n  const ry = bbox.height / 2\n  const shapeSvg = parent.insert('ellipse', ':first-child')\n    .attr('x', -bbox.width / 2)\n    .attr('y', -bbox.height / 2)\n    .attr('rx', rx)\n    .attr('ry', ry)\n\n  node.intersect = function (point) {\n    return intersectEllipse(node, rx, ry, point)\n  }\n\n  return shapeSvg\n}\n\nfunction circle (parent, bbox, node) {\n  const r = Math.max(bbox.width, bbox.height) / 2\n  const shapeSvg = parent.insert('circle', ':first-child')\n    .attr('x', -bbox.width / 2)\n    .attr('y', -bbox.height / 2)\n    .attr('r', r)\n\n  node.intersect = function (point) {\n    return intersectCircle(node, r, point)\n  }\n\n  return shapeSvg\n}\n\n// Circumscribe an ellipse for the bounding box with a diamond shape. I derived\n// the function to calculate the diamond shape from:\n// http://mathforum.org/kb/message.jspa?messageID=3750236\nfunction diamond (parent, bbox, node) {\n  const w = (bbox.width * Math.SQRT2) / 2\n  const h = (bbox.height * Math.SQRT2) / 2\n  const points = [\n    { x: 0, y: -h },\n    { x: -w, y: 0 },\n    { x: 0, y: h },\n    { x: w, y: 0 }\n  ]\n  const shapeSvg = parent.insert('polygon', ':first-child')\n    .attr('points', points.map(function (p) { return p.x + ',' + p.y }).join(' '))\n\n  node.intersect = function (p) {\n    return intersectPolygon(node, points, p)\n  }\n\n  return shapeSvg\n}\n\nexport default {\n  rect,\n  ellipse,\n  circle,\n  diamond\n}\n","import shapes from 'dagre-d3-renderer/lib/shapes'\n\nexport default class Renderer {\n\n  constructor() {\n    // this.shapes = \n  }\n\n  render(svg, g) {\n    console.log(svg)\n    const outputGroup = this.createOrSelectGroup(svg, 'output')\n    const edgePathsGroup = this.createOrSelectGroup(outputGroup, 'edgePaths')\n    const edgeLabels = this.createEdgeLabels(this.createOrSelectGroup(outputGroup, 'edgeLabels'), g)\n    const nodes = this.createNodes(this.createOrSelectGroup(outputGroup, 'nodes'), g)\n  }\n\n  createNodes(selection, g) {\n    const simpleNodes = g.nodes().filter(function(v) {return !util.isSubgraph(g, v)})\n    let svgNodes = selection.selectAll('g.node')\n\n    for (const node of nodes) {\n      const shape = shapes[node.shape]\n    }\n  }\n\n  createOrSelectGroup(root, name) {\n    let selection = root.querySelector('g.' + name)\n    if (!selection) {\n      selection = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n      selection.classList.add(name)\n      root.appendChild(selection)\n    }\n    return selection\n  }\n}","export default class FlowElement {\n  constructor(id, options) {\n    this.id = id\n    this.options = options\n    this.edges = []\n  }\n\n  leadsTo(destinationElement, options) {\n    this.edges.push({ otherId: destinationElement.id, options })\n    return destinationElement\n  }\n}\n","// import {} from \"d3\"\n// import {Graph} from \"graphlibrary\"\n// import dagreD3 from \"dagre-d3-renderer\"\nimport Graph from './Graph'\nimport Renderer from './Renderer'\nimport FlowElement from './FlowElement'\n\nexport default class FlowChart {\n  constructor(options) {\n    this.elements = []\n  }\n\n  addElement(id, options) {\n    const el = new FlowElement(id, options)\n    this.elements.push(el)\n    return el\n  }\n\n  render(element) {\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n    svg.setAttribute('id', 'f' + element.id)\n    element.appendChild(svg)\n    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n    svg.appendChild(group)\n\n    // d3\n    //   .select(element)\n    //   .append(\"svg\")\n    //   .attr(\"id\", )\n    //   .attr(\"xmlns\", \"http://www.w3.org/2000/svg\")\n\n    // Create the input mermaid.graph\n    const g = new Graph({\n      multiGraph: true,\n      compound: true\n    })\n\n    g.setGraph({\n      rankdir: 'LR',\n      marginx: 20,\n      marginy: 20\n    })\n\n    // first create all nodes\n    for (const i in this.elements) {\n      const el = this.elements[i]\n      const elData = {}\n\n      elData.label = el.id\n\n      if (el.options && el.options.label) {\n        elData.label = el.options.label\n      }\n      g.setNode(el.id, elData)\n    }\n\n    // now apply some styles to all nodes\n    for (const node of g.nodes) {\n      node.rx = node.ry = 5\n    }\n\n    // now create all edges\n    for (const i in this.elements) {\n      const el = this.elements[i]\n      for (const k in el.edges) {\n        const edge = el.edges[k]\n        const edgeData = {}\n\n        if (edge.options && edge.options.label) {\n          edgeData.label = edge.options.label\n        }\n\n        g.setEdge(el.id, edge.otherId, edgeData)\n      }\n    }\n\n    const renderer = new Renderer() // eslint-disable-line new-cap\n\n    const e = svg.querySelector('g')\n    renderer.render(e, g)\n    const svgElement = document.getElementById('f' + element.id)\n    const groupElement = svgElement.querySelector('g')\n    svgElement.style.width = groupElement.getBoundingClientRect().width + 40\n    svgElement.style.height = groupElement.getBoundingClientRect().height + 40\n  }\n}\n","<template>\n  <div \n    :id=\"_uid\" \n    class=\"flowyChart\"/>\n</template>\n\n<script>\nimport FlowChart from './FlowChart'\n\nexport default {\n  name: 'VueFlowy',\n  props: {\n    chart: {\n      type: FlowChart,\n      required: true\n    }\n  },\n  data() {\n    return {\n      chartElement: null\n    }\n  },\n  watch: {\n    'chart.elements': function(newVal, oldVal) {\n      this.chart.render(this.chartElement)\n    }\n  },\n  mounted() {\n    this.chartElement = document.getElementById(this._uid)\n  }\n}\n</script>\n\n<style lang=\"scss\">\n.flowyChart {\n  svg {\n    display: block;\n    margin: 0 auto;\n  }\n\n  .node rect {\n    stroke: #999;\n    fill: #fff;\n    stroke-width: 1.5px;\n  }\n\n  .edgePath path {\n    stroke: #333;\n    stroke-width: 1.5px;\n  }\n}\n</style>\n","import mod from \"-!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=script&lang=js\"","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","import { render, staticRenderFns } from \"./VueFlowy.vue?vue&type=template&id=6244c0f8\"\nimport script from \"./VueFlowy.vue?vue&type=script&lang=js\"\nexport * from \"./VueFlowy.vue?vue&type=script&lang=js\"\nimport style0 from \"./VueFlowy.vue?vue&type=style&index=0&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import VueFlowy from './VueFlowy.vue'\nimport FlowChart from './FlowChart.js'\n\nconst plugin = {\n  install: Vue => {\n    Vue.component(VueFlowy.name, VueFlowy)\n  }\n}\n\nVueFlowy.install = plugin.install\n\nexport default { VueFlowy, FlowChart }\n","import './setPublicPath'\nimport mod from '~entry'\nexport default mod\nexport * from '~entry'\n","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/index.js??ref--8-oneOf-2-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-2-2!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=style&index=0&lang=scss\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/index.js??ref--8-oneOf-2-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-2-2!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueFlowy.vue?vue&type=style&index=0&lang=scss\"","// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  let i\n  if ((i = window.document.currentScript) && (i = i.src.match(/(.+\\/)[^/]+\\.js$/))) {\n    __webpack_public_path__ = i[1] // eslint-disable-line\n  }\n}\n","// extracted by mini-css-extract-plugin"],"sourceRoot":""}